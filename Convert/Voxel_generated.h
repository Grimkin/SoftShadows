// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_VOXEL_LOADER_VOXEL_H_
#define FLATBUFFERS_GENERATED_VOXEL_LOADER_VOXEL_H_

#include "flatbuffers/flatbuffers.h"

namespace Loader {
namespace Voxel {

struct uint2;

struct float3;

struct Node;

struct VoxelObject;

MANUALLY_ALIGNED_STRUCT(4) uint2 FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t x_;
  uint32_t y_;

 public:
  uint2(uint32_t _x, uint32_t _y)
    : x_(flatbuffers::EndianScalar(_x)), y_(flatbuffers::EndianScalar(_y)) { }

  uint32_t x() const { return flatbuffers::EndianScalar(x_); }
  uint32_t y() const { return flatbuffers::EndianScalar(y_); }
};
STRUCT_END(uint2, 8);

MANUALLY_ALIGNED_STRUCT(4) float3 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  float3(float _x, float _y, float _z)
    : x_(flatbuffers::EndianScalar(_x)), y_(flatbuffers::EndianScalar(_y)), z_(flatbuffers::EndianScalar(_z)) { }

  float x() const { return flatbuffers::EndianScalar(x_); }
  float y() const { return flatbuffers::EndianScalar(y_); }
  float z() const { return flatbuffers::EndianScalar(z_); }
};
STRUCT_END(float3, 12);

MANUALLY_ALIGNED_STRUCT(4) Node FLATBUFFERS_FINAL_CLASS {
 private:
  uint2 Data_;
  uint32_t Pointer_;

 public:
  Node(const uint2 &_Data, uint32_t _Pointer)
    : Data_(_Data), Pointer_(flatbuffers::EndianScalar(_Pointer)) { }

  const uint2 &Data() const { return Data_; }
  uint32_t Pointer() const { return flatbuffers::EndianScalar(Pointer_); }
};
STRUCT_END(Node, 12);

struct VoxelObject FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RESOLUTION = 4,
    VT_POSITION = 6,
    VT_SIZE = 8,
    VT_NODES = 10,
    VT_POINTERS = 12
  };
  uint32_t Resolution() const { return GetField<uint32_t>(VT_RESOLUTION, 0); }
  const float3 *Position() const { return GetStruct<const float3 *>(VT_POSITION); }
  const float3 *Size() const { return GetStruct<const float3 *>(VT_SIZE); }
  const flatbuffers::Vector<const Node *> *Nodes() const { return GetPointer<const flatbuffers::Vector<const Node *> *>(VT_NODES); }
  const flatbuffers::Vector<uint32_t> *Pointers() const { return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_POINTERS); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RESOLUTION) &&
           VerifyField<float3>(verifier, VT_POSITION) &&
           VerifyField<float3>(verifier, VT_SIZE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NODES) &&
           verifier.Verify(Nodes()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_POINTERS) &&
           verifier.Verify(Pointers()) &&
           verifier.EndTable();
  }
};

struct VoxelObjectBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Resolution(uint32_t Resolution) { fbb_.AddElement<uint32_t>(VoxelObject::VT_RESOLUTION, Resolution, 0); }
  void add_Position(const float3 *Position) { fbb_.AddStruct(VoxelObject::VT_POSITION, Position); }
  void add_Size(const float3 *Size) { fbb_.AddStruct(VoxelObject::VT_SIZE, Size); }
  void add_Nodes(flatbuffers::Offset<flatbuffers::Vector<const Node *>> Nodes) { fbb_.AddOffset(VoxelObject::VT_NODES, Nodes); }
  void add_Pointers(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> Pointers) { fbb_.AddOffset(VoxelObject::VT_POINTERS, Pointers); }
  VoxelObjectBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  VoxelObjectBuilder &operator=(const VoxelObjectBuilder &);
  flatbuffers::Offset<VoxelObject> Finish() {
    auto o = flatbuffers::Offset<VoxelObject>(fbb_.EndTable(start_, 5));
    return o;
  }
};

inline flatbuffers::Offset<VoxelObject> CreateVoxelObject(flatbuffers::FlatBufferBuilder &_fbb,
   uint32_t Resolution = 0,
   const float3 *Position = 0,
   const float3 *Size = 0,
   flatbuffers::Offset<flatbuffers::Vector<const Node *>> Nodes = 0,
   flatbuffers::Offset<flatbuffers::Vector<uint32_t>> Pointers = 0) {
  VoxelObjectBuilder builder_(_fbb);
  builder_.add_Pointers(Pointers);
  builder_.add_Nodes(Nodes);
  builder_.add_Size(Size);
  builder_.add_Position(Position);
  builder_.add_Resolution(Resolution);
  return builder_.Finish();
}

inline const Loader::Voxel::VoxelObject *GetVoxelObject(const void *buf) { return flatbuffers::GetRoot<Loader::Voxel::VoxelObject>(buf); }

inline bool VerifyVoxelObjectBuffer(flatbuffers::Verifier &verifier) { return verifier.VerifyBuffer<Loader::Voxel::VoxelObject>(); }

inline void FinishVoxelObjectBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<Loader::Voxel::VoxelObject> root) { fbb.Finish(root); }

}  // namespace Voxel
}  // namespace Loader

#endif  // FLATBUFFERS_GENERATED_VOXEL_LOADER_VOXEL_H_
